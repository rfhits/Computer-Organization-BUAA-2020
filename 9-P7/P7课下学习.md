# P7课下学习

这个P7，我连教程都没看懂。  
是我太菜了，，，感觉教程就在讲谜语？/(ㄒoㄒ)/

于是开始看高老师的PPT，并且看学长代码。

我也不知道自己在写啥。。。瞎写吧

## 日程

### 2020.12.20-第一天

Pr的缩写应该是Processer，DEV我自己猜是Device(s)

#### CPU外接设备

CPU外接其他设备时，其他的设备也有自己的DataMemory。  
比如接一个U盘，CPU也会对U盘读写。

分析下具体过程：

写过程：  
CPU要算出要写的外接设备的地址，这个地址得传入到U盘里，  
CPU还得传出要写得数据具体的值，也传入到U盘里。

读过程：  
和写过程基本一样，CPU算出读的地址，不一样的地方在于，U盘这个外设要传出自己被读出的数据。  
同时，不必加上写使能。

#### 外接多设备

CPU有时候不仅要接U盘，还要接光盘（想起张伟天天说“刻光盘”了吗，hh）、接显示器、接...whatever。

每一种设备都要有自己的接口逻辑，就很麻烦，所以引入Bridge，把逻辑写到Bridge里面

其实就是把外接设备看成要读写的存储器，  
知道了这些，Bridge就不难理解了。

#### Controller

新增三大指令，，管它是干嘛的，先加上再说。  
直接跳到提交入口看端口定义

还有BD、load、store、RI信号

### 2020.12.21

#### 异常中断返回

这一部分是面对NPC逻辑的修改

面对异常和中断，PC要跳转到相应的代码段。  
所以异常处理结束后，接受eret信号，  
PC走到相应地址；  
中断来临，进入一个叫做Exception Handler的代码段。

#### PC地址异常

这是第一个要处理的异常。  
在Fetch-Stage要解析出这种异常，并且流水下去


#### 流水ExcCode

将Stage看作流水线寄存器的组合逻辑。  
ExcCode尽可能地去处理这一级发生的异常

1. Fetch阶段的异常，就是PC地址出问题，  
应对方法是，instr置为nop，ExcCode置为4

2. Decode阶段的异常，就是遇到了未定义的指令。  
注意，RI那一段的逻辑不包括nop。  
要区分正常的nop和Fetch阶段异常而产生的nop，只能通过ExcCode。  
Decode产生异常的必要条件是Fetch阶段不产生异常  
所以更新Decode下的ExcCode不能单纯凭借instr==nop

3. Execute阶段异常，为溢出异常  
普通的add和sub溢出异常  


4. Memory阶段，判断最终的异常。  
既Ld/St、hit、addr、width、AddrAligment这五者之间的矛盾  
load/store但是不hit  
load/store且hitDM，但是DMAddr没对齐，具体情况分为lw、lh、lb  
load/store且hitDEV，但是...  
这样可以分析出每一种情况，但是，，  
异常直接给了个表，大家对着表把异常逻辑写全就好了。

#### 异常与中断的处理流程

私以为这是最重要的话，可惜放到最后才讲。  
我个人倾向于拿一种异常出来，讲一下它的数据通路，  
PPT、教程什么都太抽象了，有高度，但是不深入，  
当然了，教程不可能什么都说。

>Step1-引导与识别：读取Cause和EPC寄存器，判断错误类型。  
>Step2-构造异常处理环境：保存现场。  
>Step3-处理异常：根据异常类型和其他属性执行对应处理。
>Step4-准备返回：恢复现场。  
>Step5-从异常返回：eret指令。  
>针对各类中断和异常，软件对应Step3具体对应的处理是：  
>若为中断，则视情况对外设进行操作（如修改计时器的设置），EPC不作修改。  
>若为取数异常/存数异常/算术溢出，则视情况修改EPC为受害指令的下一条。  
>若为取指异常/RI，则更改EPC的值为受害指令的下一条。

上面的step就体现了软硬件接口的思想：  
硬件检测异常和中断，并引导流水线执行handle段的代码，  
handle段就是软件来处理异常。  
我们只需要在硬件上实现功能，软件虽然要掌握，但是最后由测评机提供。

### 2020.12.22

在看wzk学长的CP0代码时，看到了“内部中断这个词”，我之前一直以为内部不能产生中断，困扰了我许久。  
到了这一天，才知道P7大体上要我们干什么。

### 2020.12.23

搭建CPU。

## 理解异常和中断

### 如何面对异常

假如，CPU通过PC从IM中fetch了一条instruction，  
但是，这个instruction没有被定义，一条Reserved Instruction。  
那么，CPU就会很茫然，它应该提醒人类，有一条指令我不认识。

假如，store指令用的addr太大了，超出了DM的范围，  
那CPU也要提醒人类，这有一条指令不行。

那CPU在面对这些异常要怎么办？

面对各种异常，CPU都要有相应的行为，我们不禁会问这些问题：  
异常指令来了，CPU怎么告诉人类？  
异常指令来了，CPU是停下来，还是接着走？

重点来了：

面对异常，课程的处理，是让流水线“进入一个函数”，一个handle异常的函数。  
这个函数事先被写在了IM中，一旦CPU“发现”了异常，  
就更改NPC，下一个时钟上升沿，从Instruction Memory中逐条fetch函数的指令，  
执行完了这个handle异常的函数，再“返回”原来异常的地方。

这个函数，不需要我们实现，我们要做的，就是引导我们的流水线，进入函数。

关键是理解函数的概念，这是从硬件的角度，自行跳转，而不是我们写汇编的函数。

### 中断

可以理解外界强制CPU进入handle段

## CP0

### 什么是CP0

CP，就是“协处理器”，遵循“高内聚，低耦合”的想法，流水线负责改GRF和DM就够了，出错的时候，让CP0教育。

如果你看过各种学长的代码，会发现他（她）们大都把这个叫做CP0的部件放在E级或M级。
你还会发现，有一个叫做ExcCode的东西被接入了这个CP0

ExcCode，是exception code的缩写，能够标识异常，比如溢出异常叫做12，取指令时地址异常叫做4...

同时，还有个HWInt的信号被接入CP0，HWInt表示外部的中断。CP0也检测外部中断，并在时钟上升沿引导pipeline。

这起码说明，CP0接入了ExcCode后，能够检测到异常，并作出相应动作。  
这个CP0，它的功能之一，就是更改NPC。  
当然了，实因为我们刚才考虑的情况非常简单，就是一条坏指令夹杂在好指令里面，  
实际情况会复杂得多，比如stall和异常一起发生、连续的异常、中断中再中断……  
要想知道CP0的具体功能，**起码要阅读下高老师的课件**，  
CP0要记录当前流水线的状态——流水还是在处理异常/中断，  
CP0还要记录外部中断是谁在给予，  
CP0还要有控制中断中中断的功能……

### 为什么CP0放在E级或M级

前面提到过，或者我们也知道，这个流水线，就是在修改GRF和DM，  
一条指令异常，就不应该被执行，也就不应该读/写DM、写GRF。  
CP0放的前面了，有的指令异常没在这一级表现出来，  
放得后面了，有的异常指令都运行完了，救不回来了。  
CP0放在E级或M级，可以检测到P6发生的所有异常，从而阻止这些行为发生。  
当然，CP0放D级也行，但是要转发  

### 异常中断的处理

加一些自己理解的术语

1. CP0检测到内部异常，会触发Internal Interrupt
2. CP0检测到外部中断（HWInt），会触发Outer Interrupt
3. 这些都是对流水线的中断，统称IntReq
4. CP0分析指令是否处于延迟槽，得到EPC，为eret
5. 流水线的NPC处逻辑引导，下一条PC变成handle段地址

## 从handle里回来

在handle里，有一条指令叫做eret，应该是exception return的缩写，  
而不是那个奇怪的英文单词。

eret被流水到CP0后，会修改CP0的状态，引导流水线回到中断/异常的那个地方。  
所以在进入handle时，这个发生异常/中断的地方，就要被记下来，  
叫做EPC，存在CP0里面。

## 细节的处理

stall时，被flush出来了nop，这些nop可能和CP0在同一级，所以CP0要接受很多PC，拿到真正的EPC

IntReq发生，后面的指令都应被flush

CP0在M级的话，DM、DEV和HI、LO的写使能问题

PC在stall时，停止fetch；遇上IntReq时，要求fetch

IntReq发生，乘除模块已经启动，是否支持撤销

eret后面的指令也因被flush

## 犯过的错

1. mfc0，WriteDataSelM没有考虑DOut，beq后面的nop没存进EPC。
sll和nop怎么区分？controller没有mfc0的A3
