# P2课下解析

## 写在前面

这次的题，参考了MondayCha的代码  
学长已经写好了C代码，按部就班地翻译就好了  
[2019-MondayCha的代码](https://github.com/MondayCha/BUAA-CO-2019)  

这种按部就班的翻译，没有什么技巧，  
考察的是细节  
我相信，  
不需要参考其他人的asm，大部人可以直接把C代码翻译成汇编

## 1-矩阵相乘

先提供两个n阶矩阵相乘的C代码：

    for(i = 0; i < n; i++){
        for(j = 0; j < n; j++){
            for (k = 0; k < n; k++){
                C[i][j] += A[i][k]*B[k][j]
            }
        }
    }

对于这一段的汇编的翻译，主要考察两个点：

1. 利用宏。定义一个get_index()的宏，返回 (i*n + j) * 4

2. for循环的写法。li、beq、j等指令要很熟练。

## 2-回文串判断

还行，一个for循环读入，一个for循环判断，设置一个flag，

    flag = 1
    for(i=0;i<n/2;i++){
        if(a[i]==a[n-1-i]){
            continue;
        }else{
            flag = 0;
            break;
        }
    }

这个比上一题简单，就是临时变量分配会多

## 3-卷积运算

“卷积”二字，重要的不是“积”，而是“卷”  
本题的关键是理解题意，写出C代码

    for (i = 0; i < m1-m2+1; i++){
        for (j = 0; j < n1-n2+1; j++){
            for(k = 0; k < m2 ; k++){
                for(l = 0; l < n2 ; l++)
                    C[i][j] += A[i+k][j+l]*B[k][l]
            }
        }
    }

连续4个循环，这个临时变量的分配也会多。。

## 4-全排列

这题的关键是写出递归。

![全排列C代码](/img/P2/permutation.jpg)

当进入子函数前，才需要进行保存，我把这个过程叫做“freeze”，

1. 将现在的参数保存在栈中

2. 改变参数，调用函数

3. 取回存储好的参数，计算好返回值

4. jr $ra 返回

递归的写法可见难点解决中的递归，
程序的细节可见4-全排列.asm

## 附加题

当祭祖出现了附加题，就要知道，这个系，已经越来越卷了。  
人上人选做

## 总结

我们可以看到，这些课上的题目，要求不是很高，  
但是很烦 : (  
考察的点有这些：

1. for循环的写法、嵌套的for循环

2. if-then-else-if_end  
这里的label的命名很烦

3. 递归写法，保存谁，返回什么

做题，要笑。。。: )
