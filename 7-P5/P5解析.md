# P5课下解析

## Prepare

### 第一天

1. 观察了教程，知道了指令的执行可以分为IF、ID、EX、MEM、WB，  
所以要添加寄存器，分段存储

2. 膜拜Pot和MondayCha两位学长的代码，知道了哪些信号需要传到下一级，并且为这些信号想出优雅的命名。  
参考了MondayCha的，在信号的最后面加上级别的名称。

3. 在Logisim中搭建各个流水线寄存器

4. 发现按照P4模型，beq、J型指令的数据通路不对，  
猜到有nop在这类指令后面。并且NPC模块接受输入是D级的PC。  
或者说，NPC有点不纯粹，既有PC直接输入，又有D级的PC输入。

5. 本来以为搭好数据通路就完事了，我没发现有冲突。。。（抱歉，，是我智商不够。。  
看了很久Tuse和Tnew，因为没有理解一句话，不知道有啥用。。  
阅读Wander博客，知道lw和计算类型（姑且就叫做cal类 的指令吧），在操作同一个寄存器时，会产生冲突，  
这才明白所谓Tuse和Tnew想干嘛。

### 第二天

1. Tuse是当某条指令还在D级（也就是还没写入DE级流水线寄存器的时候）时，至少再等多少个周期（也可以说是还得再来几个上升沿）就必须用到数据

2. Tnew是当某条能写入数据的指令，再过多少个周期才能产生最新数据（此处的产生是已经写入到流水线寄存器，如果只是刚算出来还没写入流水线寄存器的话我们不认为是产生，原因考虑时钟周期）  
位于某个流水级的某个指令，它经过多少个时钟周期可以算出结果并且存储到流水级寄存器里。

3. 当Tuse>=Tnew时，是可以来得及转发的；当Tuse < Tnew时，是来不及转发的，必须暂停

4. 研究转发，依旧没有头绪，从狼书入手  
再次构建CPU

### 第三天

1. 吐槽，中文命名法、“超详细命名法”，我甚至还看到了“锟斤拷”？？？。。。  
有的代码可读性真的不强。

2. 终于，看懂了MondayCha学长的一点代码，开始搭建Hazard中的Forward部分

### 第四天

直接在logisim中搭一遍kxh学长的  
并且写自己的

### 第五天

直接淦到Forward-Control，以我现在的水平，认为还差Stall-Control和beq发生跳转后的清零。  
看到一个比较好的讲解暂停，附上链接：  
[暂停的讲解](https://blog.csdn.net/weixin_43699738/article/details/107515764)

### 第n天-2020.11.29

终于理解了kxh学长的代码。  
ta不是采用Tuse-Tnew的方法，而是直接判断哪些会冲突。

此时，还要注意转发和暂停可能的冲突以及jal和jalr的特殊性  
防止把jal和jalr给暂停了

## 上手搭建

### Forward机制

凡是需要读取寄存器的地方，都需要Forward。  
Forward还有优先级

### GRF的内部转发机制

the internal forwarding of GRF

凡是涉及到读取寄存器的操作，都离不开转发

GRF的WriteData和来自WriteBack单元。  
所以转发的数据不是来自forward，而是直接WriteData。

### jal的数据通路

jal在Decode阶段，就产生了要写入到GRF的信号。  
所以WriteData这个信号，最早是在Decode阶段就产生了，  
而不是在Execute阶段产生

## 有了思路之后的问题

### 命名

有的模块被译出来的信号，在后续模块中可能还会被修改。  
所以这个时候，不能把它的名字给定下来。  
和Kxh的代码一样，stage的输出将表示来和去两个方向，而Reg的输入输出将直接表示一个方向。  
这样可以有效避免命名冲突问题。
